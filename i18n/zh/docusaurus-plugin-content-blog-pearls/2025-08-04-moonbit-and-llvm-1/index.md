---
description: 'Moonbit ä¸ llvm å…±èˆ ä¸Šç¯‡ - å®ç°è¯­æ³•å‰ç«¯'
slug: moonbit-and-llvm-1
image: cover.png
---

# Moonbit ä¸ llvm å…±èˆ ä¸Šç¯‡ - å®ç°è¯­æ³•å‰ç«¯

![](./cover.png)

---

## å¼•è¨€

ç¼–ç¨‹è¯­è¨€è®¾è®¡ä¸ç¼–è¯‘å™¨å®ç°å†æ¥è¢«è§†ä¸ºè®¡ç®—æœºç§‘å­¦é¢†åŸŸä¸­æœ€å…·æŒ‘æˆ˜æ€§çš„è¯¾é¢˜ä¹‹ä¸€ã€‚ä¼ ç»Ÿçš„ç¼–è¯‘å™¨æ•™å­¦è·¯å¾„å¾€å¾€è¦æ±‚å­¦ç”Ÿé¦–å…ˆæŒæ¡å¤æ‚çš„ç†è®ºåŸºç¡€ï¼š

- **è‡ªåŠ¨æœºç†è®º**ï¼šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºä¸æ­£åˆ™è¡¨è¾¾å¼
- **ç±»å‹ç†è®º**ï¼šÎ»æ¼”ç®—ä¸ç±»å‹ç³»ç»Ÿçš„æ•°å­¦åŸºç¡€
- **è®¡ç®—æœºä½“ç³»ç»“æ„**ï¼šä»æ±‡ç¼–è¯­è¨€åˆ°æœºå™¨ç çš„åº•å±‚å®ç°

ç„¶è€Œï¼ŒMoonbitä½œä¸ºä¸€é—¨ä¸“ä¸ºç°ä»£å¼€å‘ç¯å¢ƒè®¾è®¡çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼Œä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªå…¨æ–°çš„è§†è§’ã€‚å®ƒä¸ä»…å…·å¤‡ä¸¥è°¨çš„ç±»å‹ç³»ç»Ÿå’Œå“è¶Šçš„å†…å­˜å®‰å…¨ä¿éšœï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œå…¶ä¸°å¯Œçš„è¯­æ³•ç‰¹æ€§å’Œä¸ºAIæ—¶ä»£é‡èº«å®šåˆ¶çš„å·¥å…·é“¾ï¼Œä½¿å¾—Moonbitæˆä¸ºå­¦ä¹ å’Œå®ç°ç¼–è¯‘å™¨çš„ç†æƒ³é€‰æ‹©ã€‚

> **ç³»åˆ—æ¦‚è¿°**
> æœ¬ç³»åˆ—æ–‡ç« å°†é€šè¿‡æ„å»ºä¸€ä¸ªåä¸º**TinyMoonbit**çš„å°å‹ç¼–ç¨‹è¯­è¨€ç¼–è¯‘å™¨ï¼Œæ·±å…¥æ¢è®¨ç°ä»£ç¼–è¯‘å™¨å®ç°çš„æ ¸å¿ƒæ¦‚å¿µå’Œæœ€ä½³å®è·µã€‚
>
> - **ä¸Šç¯‡**ï¼šèšç„¦è¯­è¨€å‰ç«¯çš„å®ç°ï¼ŒåŒ…æ‹¬è¯æ³•åˆ†æã€è¯­æ³•è§£æå’Œç±»å‹æ£€æŸ¥ï¼Œæœ€ç»ˆç”Ÿæˆå¸¦æœ‰å®Œæ•´ç±»å‹æ ‡è®°çš„æŠ½è±¡è¯­æ³•æ ‘
> - **ä¸‹ç¯‡**ï¼šæ·±å…¥ä»£ç ç”Ÿæˆé˜¶æ®µï¼Œåˆ©ç”¨Moonbitå®˜æ–¹çš„`llvm.mbt`â€‹ç»‘å®šåº“ï¼Œå°†è¯­æ³•æ ‘è½¬æ¢ä¸ºLLVMä¸­é—´è¡¨ç¤ºï¼Œå¹¶æœ€ç»ˆç”ŸæˆRISC-Væ±‡ç¼–ä»£ç 

---

## TinyMoonbit è¯­è¨€è®¾è®¡

TinyMoonbitæ˜¯ä¸€ç§ç³»ç»Ÿçº§ç¼–ç¨‹è¯­è¨€ï¼Œå…¶æŠ½è±¡å±‚æ¬¡ä¸Cè¯­è¨€ç›¸å½“ã€‚è™½ç„¶åœ¨è¯­æ³•è®¾è®¡ä¸Šå¤§é‡å€Ÿé‰´äº†Moonbitçš„ç‰¹æ€§ï¼Œä½†TinyMoonbitå®é™…å¹¶éMoonbitè¯­è¨€çš„å­é›†ï¼Œè€Œæ˜¯ä¸€ä¸ªä¸ºæµ‹è¯•`llvm.mbt`â€‹åŠŸèƒ½å®Œå¤‡æ€§å…¼å…·æ•™å­¦ä½œç”¨çš„ç®€åŒ–ç‰ˆæœ¬ã€‚

> æ³¨ï¼šç”±äºç¯‡å¹…é™åˆ¶ï¼Œæœ¬ç³»åˆ—æ–‡ç« æ‰€æåˆ°çš„TinyMoonbitå®ç°æ¯”çœŸæ­£çš„TinyMoonbitæ›´åŠ ç®€å•ï¼Œå®Œæ•´ç‰ˆæœ¬è¯·å‚è€ƒ [TinyMoonbitLLVM](https://github.com/moonbitlang/llvm.mbt)ã€‚

### æ ¸å¿ƒç‰¹æ€§

TinyMoonbitæä¾›äº†ç°ä»£ç³»ç»Ÿç¼–ç¨‹æ‰€éœ€çš„åŸºç¡€åŠŸèƒ½ï¼š

- âœ… **åº•å±‚å†…å­˜æ“ä½œ**ï¼šç›´æ¥çš„æŒ‡é’ˆæ“ä½œå’Œå†…å­˜ç®¡ç†
- âœ… **æ§åˆ¶æµç»“æ„**ï¼šæ¡ä»¶åˆ†æ”¯ã€å¾ªç¯å’Œå‡½æ•°è°ƒç”¨
- âœ… **ç±»å‹å®‰å…¨**ï¼šé™æ€ç±»å‹æ£€æŸ¥å’Œæ˜ç¡®çš„ç±»å‹å£°æ˜
- âŒ **ç®€åŒ–è®¾è®¡**ï¼šä¸ºé™ä½å®ç°å¤æ‚åº¦ï¼Œä¸æ”¯æŒç±»å‹æ¨å¯¼å’Œé—­åŒ…ç­‰é«˜çº§ç‰¹æ€§

### è¯­æ³•ç¤ºä¾‹

è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç»å…¸çš„æ–æ³¢é‚£å¥‘æ•°åˆ—å®ç°æ¥å±•ç¤ºTinyMoonbitçš„è¯­æ³•ï¼š

```moonbit
extern fn print_int(x : Int) -> Unit;

// é€’å½’å®ç°æ–æ³¢é‚£å¥‘æ•°åˆ—
fn fib(n : Int) -> Int {
  if n <= 1 {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}

fn main() -> Unit {
  print_int(fib(10));
}
```

### ç¼–è¯‘ç›®æ ‡

ç»è¿‡å®Œæ•´çš„ç¼–è¯‘æµç¨‹åï¼Œä¸Šè¿°ä»£ç å°†ç”Ÿæˆå¦‚ä¸‹çš„LLVMä¸­é—´è¡¨ç¤ºï¼š

```llvm
; ModuleID = 'tinymoonbit'
source_filename = "tinymoonbit"

define i32 @fib(i32 %0) {
entry:
  %1 = alloca i32, align 4
  store i32 %0, ptr %1, align 4
  %2 = load i32, ptr %1, align 4
  %3 = icmp sle i32 %2, 1
  br i1 %3, label %4, label %6

4:                                                ; preds = %entry
  %5 = load i32, ptr %1, align 4
  ret i32 %5

6:                                                ; preds = %4, %entry
  %7 = load i32, ptr %1, align 4
  %8 = sub i32 %7, 1
  %9 = call i32 @fib(i32 %8)
  %10 = load i32, ptr %1, align 4
  %11 = sub i32 %10, 2
  %12 = call i32 @fib(i32 %11)
  %13 = add i32 %9, %12
  ret i32 %13
}

define void @main() {
entry:
  %0 = call i32 @fib(i32 10)
  call void @print_int(i32 %0)
}

declare void @print_int(i32 %0)
```

---

## ç¬¬äºŒç« ï¼šè¯æ³•åˆ†æ

**è¯æ³•åˆ†æ**ï¼ˆLexical Analysisï¼‰æ„æˆäº†ç¼–è¯‘è¿‡ç¨‹çš„ç¬¬ä¸€é“å…³å¡ï¼Œå…¶æ ¸å¿ƒä½¿å‘½æ˜¯å°†è¿ç»­çš„å­—ç¬¦æµè½¬æ¢ä¸ºå…·æœ‰è¯­ä¹‰æ„ä¹‰çš„**è¯æ³•å•å…ƒ**ï¼ˆTokensï¼‰åºåˆ—ã€‚è¿™ä¸ªçœ‹ä¼¼ç®€å•çš„è½¬æ¢è¿‡ç¨‹ï¼Œå®é™…ä¸Šæ˜¯æ•´ä¸ªç¼–è¯‘å™¨æµæ°´çº¿çš„åŸºçŸ³ã€‚

### ä»å­—ç¬¦åˆ°ç¬¦å·ï¼šTokençš„è®¾è®¡ä¸å®ç°

è€ƒè™‘ä»¥ä¸‹ä»£ç ç‰‡æ®µï¼š

```moonbit
let x : Int = 5;
```

ç»è¿‡è¯æ³•åˆ†æå™¨å¤„ç†åï¼Œå°†äº§ç”Ÿå¦‚ä¸‹çš„Tokenåºåˆ—ï¼š

```
(Keyword "let") â†’ (Identifier "x") â†’ (Symbol ":") â†’
(Type "Int") â†’ (Operator "=") â†’ (IntLiteral 5) â†’ (Symbol ";")
```

è¿™ä¸ªè½¬æ¢è¿‡ç¨‹éœ€è¦å¤„ç†å¤šç§å¤æ‚æƒ…å†µï¼š

1. **ç©ºç™½ç¬¦è¿‡æ»¤**ï¼šè·³è¿‡ç©ºæ ¼ã€åˆ¶è¡¨ç¬¦å’Œæ¢è¡Œç¬¦
2. **å…³é”®å­—è¯†åˆ«**ï¼šåŒºåˆ†ä¿ç•™å­—ä¸ç”¨æˆ·å®šä¹‰æ ‡è¯†ç¬¦
3. **æ•°å€¼è§£æ**ï¼šæ­£ç¡®è¯†åˆ«æ•´æ•°ã€æµ®ç‚¹æ•°çš„è¾¹ç•Œ
4. **è¿ç®—ç¬¦å¤„ç†**ï¼šåŒºåˆ†å•å­—ç¬¦å’Œå¤šå­—ç¬¦è¿ç®—ç¬¦

### Tokenç±»å‹ç³»ç»Ÿè®¾è®¡

åŸºäºTinyMoonbitçš„è¯­æ³•è§„èŒƒï¼Œæˆ‘ä»¬å°†æ‰€æœ‰å¯èƒ½çš„ç¬¦å·åˆ†ç±»ä¸ºä»¥ä¸‹Tokenç±»å‹ï¼š

```moonbit
pub enum Token {
  Bool(Bool)       // å¸ƒå°”å€¼ï¼štrue, false
  Int(Int)         // æ•´æ•°ï¼š1, 2, 3, ...
  Double(Double)   // æµ®ç‚¹æ•°ï¼š1.0, 2.5, 3.14, ...
  Keyword(String)  // ä¿ç•™å­—ï¼šlet, if, while, fn, return
  Upper(String)    // ç±»å‹æ ‡è¯†ç¬¦ï¼šé¦–å­—æ¯å¤§å†™ï¼Œå¦‚ Int, Double, Bool
  Lower(String)    // å˜é‡æ ‡è¯†ç¬¦ï¼šé¦–å­—æ¯å°å†™ï¼Œå¦‚ x, y, result
  Symbol(String)   // è¿ç®—ç¬¦å’Œæ ‡ç‚¹ï¼š+, -, *, :, ;, ->
  Bracket(Char)    // æ‹¬å·ç±»ï¼š(, ), [, ], {, }
  EOF              // æ–‡ä»¶ç»“æŸæ ‡è®°
} derive(Show, Eq)
```

### åˆ©ç”¨æ¨¡å¼åŒ¹é…

Moonbitçš„å¼ºå¤§æ¨¡å¼åŒ¹é…èƒ½åŠ›ä½¿æˆ‘ä»¬èƒ½å¤Ÿä»¥ä¸€ç§å‰æ‰€æœªæœ‰çš„ä¼˜é›…æ–¹å¼å®ç°è¯æ³•åˆ†æå™¨ã€‚ä¸ä¼ ç»Ÿçš„æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºæ–¹æ³•ç›¸æ¯”ï¼Œè¿™ç§åŸºäºæ¨¡å¼åŒ¹é…çš„å®ç°æ›´åŠ ç›´è§‚å’Œæ˜“äºç†è§£ã€‚

#### æ ¸å¿ƒåˆ†æå‡½æ•°

```moonbit
pub fn lex(code: String) -> Array[Token] {
  let tokens = Array::new()

  loop code[:] {
    // è·³è¿‡ç©ºç™½å­—ç¬¦
    [' ' | '\n' | '\r' | '\t', ..rest] =>
      continue rest

    // å¤„ç†å•è¡Œæ³¨é‡Š
    [.."//", ..rest] =>
      continue loop rest {
        ['\n' | '\r', ..rest_str] => break rest_str
        [_, ..rest_str] => continue rest_str
        [] as rest_str => break rest_str
      }

    // è¯†åˆ«å¤šå­—ç¬¦è¿ç®—ç¬¦ï¼ˆé¡ºåºå¾ˆé‡è¦ï¼ï¼‰
    [.."->", ..rest] => { tokens.push(Symbol("->")); continue rest }
    [.."==", ..rest] => { tokens.push(Symbol("==")); continue rest }
    [.."!=", ..rest] => { tokens.push(Symbol("!=")); continue rest }
    [.."<=", ..rest] => { tokens.push(Symbol("<=")); continue rest }
    [..">=", ..rest] => { tokens.push(Symbol(">=")); continue rest }

    // è¯†åˆ«å•å­—ç¬¦è¿ç®—ç¬¦å’Œæ ‡ç‚¹ç¬¦å·
    [':' | '.' | ',' | ';' | '+' | '-' | '*' |
     '/' | '%' | '>' | '<' | '=' as c, ..rest] => {
      tokens.push(Symbol("\{c}"))
      continue rest
    }

    // è¯†åˆ«æ‹¬å·
    ['(' | ')' | '[' | ']' | '{' | '}' as c, ..rest] => {
      tokens.push(Bracket(c))
      continue rest
    }

    // è¯†åˆ«æ ‡è¯†ç¬¦å’Œå­—é¢é‡
    ['a'..='z', ..] as code => {
      let (tok, rest) = lex_ident(code);
      tokens.push(tok)
      continue rest
    }

    ['A'..='Z', ..] => { ... }
    ['0'..='9', ..] => { ... }

    // åˆ°è¾¾æ–‡ä»¶æœ«å°¾
    [] => { tokens.push(EOF); break tokens }
  }
}
```

#### å…³é”®å­—è¯†åˆ«ç­–ç•¥

æ ‡è¯†ç¬¦è§£æéœ€è¦ç‰¹åˆ«å¤„ç†å…³é”®å­—çš„è¯†åˆ«ï¼š

```moonbit
pub fn let_ident(rest: @string.View) -> (Token, @string.View) {
  // é¢„å®šä¹‰å…³é”®å­—æ˜ å°„è¡¨
  let keyword_map = Map.from_array([
    ("let", Token::Keyword("let")),
    ("fn", Token::Keyword("fn")),
    ("if", Token::Keyword("if")),
    ("else", Token::Keyword("else")),
    ("while", Token::Keyword("while")),
    ("return", Token::Keyword("return")),
    ("extern", Token::Keyword("extern")),
    ("true", Token::Bool(true)),
    ("false", Token::Bool(false)),
  ])

  let identifier_chars = Array::new()
  let remaining = loop rest {
    ['a'..='z' | 'A'..='Z' | '0'..='9' | '_' as c, ..rest_str] => {
      identifier_chars.push(c)
      continue rest_str
    }
    _ as rest_str => break rest_str
  }

  let ident = String::from_array(identifier_chars)
  let token = keyword_map.get(identifier).or_else(() => Token::Lower(ident))

  (token, remaining)
}
```

### ğŸ’¡ Moonbitè¯­æ³•ç‰¹æ€§æ·±åº¦è§£æ

ä¸Šè¿°è¯æ³•åˆ†æå™¨çš„å®ç°å……åˆ†å±•ç¤ºäº†Moonbitåœ¨ç¼–è¯‘å™¨å¼€å‘ä¸­çš„å‡ ä¸ªçªå‡ºä¼˜åŠ¿ï¼š

1. å‡½æ•°å¼å¾ªç¯æ„é€ 

```moonbit
loop initial_value {
  pattern1 => continue new_value1
  pattern2 => continue new_value2
  pattern3 => break final_value
}
```

â€‹`loop`â€‹å¹¶éä¼ ç»Ÿæ„ä¹‰ä¸Šçš„å¾ªç¯ç»“æ„ï¼Œè€Œæ˜¯ä¸€ç§**å‡½æ•°å¼å¾ªç¯**ï¼š

- æ¥å—ä¸€ä¸ªåˆå§‹å‚æ•°ä½œä¸ºå¾ªç¯çŠ¶æ€
- é€šè¿‡æ¨¡å¼åŒ¹é…å¤„ç†ä¸åŒæƒ…å†µ
- â€‹`continue`â€‹ä¼ é€’æ–°çŠ¶æ€åˆ°ä¸‹ä¸€æ¬¡è¿­ä»£
- â€‹`break`â€‹ç»ˆæ­¢å¾ªç¯å¹¶è¿”å›æœ€ç»ˆå€¼

2. å­—ç¬¦ä¸²è§†å›¾ä¸æ¨¡å¼åŒ¹é…

Moonbitçš„å­—ç¬¦ä¸²æ¨¡å¼åŒ¹é…åŠŸèƒ½æå¤§ç®€åŒ–äº†æ–‡æœ¬å¤„ç†ï¼š

```moonbit
// åŒ¹é…å•ä¸ªå­—ç¬¦
['a', ..rest] => // ä»¥å­—ç¬¦'a'å¼€å¤´

// åŒ¹é…å­—ç¬¦èŒƒå›´
['a'..='z' as c, ..rest] => // å°å†™å­—æ¯ï¼Œç»‘å®šåˆ°å˜é‡c

// åŒ¹é…å­—ç¬¦ä¸²å­—é¢é‡
[.."hello", ..rest] => // ç­‰ä»·äº ['h','e','l','l','o', ..rest]

// åŒ¹é…å¤šä¸ªå¯èƒ½çš„å­—ç¬¦
[' ' | '\t' | '\n', ..rest] => // ä»»æ„ç©ºç™½å­—ç¬¦
```

3. æ¨¡å¼åŒ¹é…ä¼˜å…ˆçº§çš„é‡è¦æ€§

> âš ï¸ **é‡è¦æé†’ï¼šåŒ¹é…é¡ºåºè‡³å…³é‡è¦**
>
> åœ¨ç¼–å†™æ¨¡å¼åŒ¹é…è§„åˆ™æ—¶ï¼Œå¿…é¡»å°†æ›´å…·ä½“çš„æ¨¡å¼æ”¾åœ¨æ›´ä¸€èˆ¬çš„æ¨¡å¼ä¹‹å‰ã€‚ä¾‹å¦‚ï¼š
>
> ```moonbit
> // âœ… æ­£ç¡®çš„é¡ºåº
> loop code[:] {
>   [.."->", ..rest] => { ... }     // å…ˆåŒ¹é…å¤šå­—ç¬¦è¿ç®—ç¬¦
>   ['-' | '>' as c, ..rest] => { ... }  // å†åŒ¹é…å•å­—ç¬¦
> }
>
> // âŒ é”™è¯¯çš„é¡ºåº - "->"å°†æ°¸è¿œæ— æ³•è¢«åŒ¹é…
> loop code[:] {
>   ['-' | '>' as c, ..rest] => { ... }
>   [.."->", ..rest] => { ... }     // æ°¸è¿œä¸ä¼šæ‰§è¡Œ
> }
> ```

é€šè¿‡è¿™ç§åŸºäºæ¨¡å¼åŒ¹é…çš„æ–¹æ³•ï¼Œæˆ‘ä»¬ä¸ä»…é¿å…äº†å¤æ‚çš„çŠ¶æ€æœºå®ç°ï¼Œè¿˜è·å¾—äº†æ›´æ¸…æ™°ã€æ›´å®¹æ˜“ç»´æŠ¤çš„ä»£ç ç»“æ„ã€‚

---

## ç¬¬ä¸‰ç« ï¼šè¯­æ³•åˆ†æä¸æŠ½è±¡è¯­æ³•æ ‘æ„å»º

**è¯­æ³•åˆ†æ**ï¼ˆSyntactic Analysisï¼‰æ˜¯ç¼–è¯‘å™¨çš„ç¬¬äºŒä¸ªæ ¸å¿ƒé˜¶æ®µï¼Œå…¶ä»»åŠ¡æ˜¯å°†è¯æ³•åˆ†æäº§ç”Ÿçš„Tokenåºåˆ—é‡æ–°ç»„ç»‡ä¸ºå…·æœ‰å±‚æ¬¡ç»“æ„çš„**æŠ½è±¡è¯­æ³•æ ‘**ï¼ˆAbstract Syntax Tree, ASTï¼‰ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸ä»…è¦éªŒè¯ç¨‹åºæ˜¯å¦ç¬¦åˆè¯­è¨€çš„è¯­æ³•è§„åˆ™ï¼Œæ›´è¦ä¸ºåç»­çš„è¯­ä¹‰åˆ†æå’Œä»£ç ç”Ÿæˆæä¾›ç»“æ„åŒ–çš„æ•°æ®è¡¨ç¤ºã€‚

### æŠ½è±¡è¯­æ³•æ ‘è®¾è®¡ï¼šç¨‹åºçš„ç»“æ„åŒ–è¡¨ç¤º

åœ¨æ„å»ºè¯­æ³•åˆ†æå™¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ç²¾å¿ƒè®¾è®¡ASTçš„ç»“æ„ã€‚è¿™ä¸ªè®¾è®¡å†³å®šäº†å¦‚ä½•è¡¨ç¤ºç¨‹åºçš„è¯­æ³•ç»“æ„ï¼Œä»¥åŠåç»­ç¼–è¯‘é˜¶æ®µå¦‚ä½•å¤„ç†è¿™äº›ç»“æ„ã€‚

#### 1. æ ¸å¿ƒç±»å‹ç³»ç»Ÿ

é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰TinyMoonbitç±»å‹ç³»ç»Ÿåœ¨ASTä¸­çš„è¡¨ç¤ºï¼š

```moonbit
pub enum Type {
  Unit    // å•ä½ç±»å‹ï¼Œè¡¨ç¤ºæ— è¿”å›å€¼
  Bool    // å¸ƒå°”ç±»å‹ï¼štrue, false
  Int     // 32ä½æœ‰ç¬¦å·æ•´æ•°
  Double  // 64ä½åŒç²¾åº¦æµ®ç‚¹æ•°
} derive(Show, Eq, ToJson)

pub fn parse_type(type_name: String) -> Type {
  match type_name {
    "Unit" => Type::Unit
    "Bool" => Type::Bool
    "Int" => Type::Int
    "Double" => Type::Double
    _ => abort("Unknown type: \{type_name}")
  }
}
```

#### 2. åˆ†å±‚çš„ASTèŠ‚ç‚¹è®¾è®¡

æˆ‘ä»¬é‡‡ç”¨åˆ†å±‚è®¾è®¡æ¥æ¸…æ™°åœ°è¡¨ç¤ºç¨‹åºçš„ä¸åŒæŠ½è±¡å±‚æ¬¡ï¼š

1. åŸå­è¡¨è¾¾å¼ï¼ˆAtomExprï¼‰
   ä»£è¡¨ä¸å¯å†åˆ†è§£çš„åŸºæœ¬è¡¨è¾¾å¼å•å…ƒï¼š

```moonbit
pub enum AtomExpr {
  Bool(Bool)                                    // å¸ƒå°”å­—é¢é‡
  Int(Int)                                      // æ•´æ•°å­—é¢é‡
  Double(Double)                                // æµ®ç‚¹æ•°å­—é¢é‡
  Var(String, mut ty~ : Type?)                  // å˜é‡å¼•ç”¨
  Paren(Expr, mut ty~ : Type?)                  // æ‹¬å·è¡¨è¾¾å¼
  Call(String, Array[Expr], mut ty~ : Type?)    // å‡½æ•°è°ƒç”¨
} derive(Show, Eq, ToJson)
```

2. å¤åˆè¡¨è¾¾å¼ï¼ˆExprï¼‰
   å¯ä»¥åŒ…å«è¿ç®—ç¬¦å’Œå¤šä¸ªå­è¡¨è¾¾å¼çš„æ›´å¤æ‚ç»“æ„ï¼š

```moonbit
pub enum Expr {
  AtomExpr(AtomExpr, mut ty~ : Type?)          // åŸå­è¡¨è¾¾å¼åŒ…è£…
  Unary(String, Expr, mut ty~ : Type?)         // ä¸€å…ƒè¿ç®—ï¼š-, !
  Binary(String, Expr, Expr, mut ty~ : Type?)  // äºŒå…ƒè¿ç®—ï¼š+, -, *, /, ==, !=, ç­‰
} derive(Show, Eq, ToJson)
```

3. è¯­å¥ï¼ˆStmtï¼‰
   ä»£è¡¨ç¨‹åºä¸­çš„å¯æ‰§è¡Œå•å…ƒï¼š

```moonbit
pub enum Stmt {
  Let(String, Type, Expr)                      // å˜é‡å£°æ˜ï¼šlet x : Int = 5;
  Assign(String, Expr)                         // èµ‹å€¼è¯­å¥ï¼šx = 10;
  If(Expr, Array[Stmt], Array[Stmt])           // æ¡ä»¶åˆ†æ”¯ï¼šif-else
  While(Expr, Array[Stmt])                     // å¾ªç¯è¯­å¥ï¼šwhile
  Return(Expr?)                                // è¿”å›è¯­å¥ï¼šreturn expr;
  Expr(Expr)                                   // å•è¡¨è¾¾å¼è¯­å¥
} derive(Show, Eq, ToJson)
```

4. é¡¶å±‚ç»“æ„
   å‡½æ•°å®šä¹‰å’Œå®Œæ•´ç¨‹åºï¼š

```moonbit
pub struct Function {
  name : String                     // å‡½æ•°å
  params : Array[(String, Type)]    // å‚æ•°åˆ—è¡¨ï¼š[(å‚æ•°å, ç±»å‹)]
  ret_ty : Type                     // è¿”å›ç±»å‹
  body : Array[Stmt]                // å‡½æ•°ä½“è¯­å¥åºåˆ—
} derive(Show, Eq, ToJson)

// ç¨‹åºå®šä¹‰ä¸ºå‡½æ•°ååˆ°å‡½æ•°å®šä¹‰çš„æ˜ å°„
pub type Program Map[String, Function]
```

> **è®¾è®¡è¦ç‚¹ï¼šç±»å‹æ ‡è®°çš„å¯å˜æ€§**
>
> æ³¨æ„åˆ°æ¯ä¸ªè¡¨è¾¾å¼èŠ‚ç‚¹éƒ½åŒ…å«ä¸€ä¸ª `mut ty~ : Type?`â€‹ å­—æ®µã€‚è¿™ä¸ªè®¾è®¡å…è®¸æˆ‘ä»¬åœ¨ç±»å‹æ£€æŸ¥é˜¶æ®µå¡«å……ç±»å‹ä¿¡æ¯ï¼Œè€Œä¸éœ€è¦é‡æ–°æ„å»ºæ•´ä¸ªASTã€‚

### é€’å½’ä¸‹é™è§£æï¼šè‡ªé¡¶å‘ä¸‹çš„æ„å»ºç­–ç•¥

**é€’å½’ä¸‹é™**ï¼ˆRecursive Descentï¼‰æ˜¯ä¸€ç§è‡ªé¡¶å‘ä¸‹çš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯ä¸ºæ¯ä¸ªè¯­æ³•è§„åˆ™ç¼–å†™ä¸€ä¸ªå¯¹åº”çš„è§£æå‡½æ•°ã€‚åœ¨Moonbitä¸­ï¼Œæ¨¡å¼åŒ¹é…ä½¿è¿™ç§æ–¹æ³•çš„å®ç°å˜å¾—å¼‚å¸¸ä¼˜é›…ã€‚

#### è§£æåŸå­è¡¨è¾¾å¼

```moonbit
pub fn parse_atom_expr(
  tokens: ArrayView[Token]
) -> (AtomExpr, ArrayView[Token]) raise {
  match tokens {
    // è§£æå­—é¢é‡
    [Bool(b), ..rest] => (AtomExpr::Bool(b), rest)
    [Int(i), ..rest] => (AtomExpr::Int(i), rest)
    [Double(d), ..rest] => (AtomExpr::Double(d), rest)

    // è§£æå‡½æ•°è°ƒç”¨ï¼šfunc_name(arg1, arg2, ...)
    [Lower(func_name), Bracket('('), ..rest] => {
      let (args, rest) = parse_argument_list(rest)
      match rest {
        [Bracket(')'), ..remaining] =>
          (AtomExpr::Call(func_name, args, ty=None), remaining)
        _ => raise SyntaxError("Expected ')' after function arguments")
      }
    }

    // è§£æå˜é‡å¼•ç”¨
    [Lower(var_name), ..rest] =>
      (AtomExpr::Var(var_name, ty=None), rest)

    // è§£ææ‹¬å·è¡¨è¾¾å¼ï¼š(expression)
    [Bracket('('), ..rest] => {
      let (expr, rest) = parse_expression(rest)
      match rest {
        [Bracket(')'), ..remaining] =>
          (AtomExpr::Paren(expr, ty=None), remaining)
        _ => raise SyntaxError("Expected ')' after expression")
      }
    }

    _ => raise SyntaxError("Expected atomic expression")
  }
}
```

#### è§£æè¯­å¥

è¯­å¥è§£æéœ€è¦æ ¹æ®å¼€å¤´çš„å…³é”®å­—åˆ†å‘åˆ°ä¸åŒçš„å¤„ç†å‡½æ•°ï¼š

```moonbit
pub fn parse_stmt(tokens : ArrayView[Token]) -> (Stmt, ArrayView[Token]) {
  match tokens {
    // è§£æletè¯­å¥
    [Keyword("let"), Lower(var_name), Symbol(":"), ..] => { /* ... */ }

    // è§£æif/while/returnè¯­å¥
    [Keyword("if"), .. rest] => parse_if_stmt(rest)
    [Keyword("while"), .. rest] => parse_while_stmt(rest)
    [Keyword("return"), .. rest] => { /* ... */ }

    // è§£æèµ‹å€¼è¯­å¥
    [Lower(_), Symbol("="), .. rest] => parse_assign_stmt(tokens)

    // è§£æå•è¡¨è¾¾å¼è¯­å¥
    [Lower(_), Symbol("="), .. rest] => parse_single_expr_stmt(tokens)

    _ => { /* é”™è¯¯å¤„ç† */ }
  }
}
```

> **éš¾ç‚¹**ï¼šå¤„ç†è¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼š
>
> è¡¨è¾¾å¼è§£æä¸­æœ€å¤æ‚çš„éƒ¨åˆ†æ˜¯å¤„ç†è¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿1 + 2 _ 3è¢«æ­£ç¡®è§£æä¸º1 + (2 _ 3)è€Œä¸æ˜¯(1 + 2) \* 3ã€‚

### ğŸ’¡ Moonbité«˜çº§ç‰¹æ€§åº”ç”¨

#### è‡ªåŠ¨æ´¾ç”ŸåŠŸèƒ½

```moonbit
pub enum Expr {
  // ...
} derive(Show, Eq, ToJson)
```

Moonbitçš„ `derive`â€‹ åŠŸèƒ½è‡ªåŠ¨ä¸ºç±»å‹ç”Ÿæˆå¸¸ç”¨çš„å®ç°ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ä¸‰ä¸ªï¼š

- â€‹**â€‹`Show`â€‹**â€‹ï¼šæä¾›è°ƒè¯•è¾“å‡ºåŠŸèƒ½
- â€‹**â€‹`Eq`â€‹**â€‹ï¼šæ”¯æŒç›¸ç­‰æ€§æ¯”è¾ƒ
- â€‹**â€‹`ToJson`â€‹**â€‹ï¼šåºåˆ—åŒ–ä¸ºJSONæ ¼å¼ï¼Œä¾¿äºè°ƒè¯•å’ŒæŒä¹…åŒ–

è¿™äº›è‡ªåŠ¨ç”Ÿæˆçš„åŠŸèƒ½åœ¨ç¼–è¯‘å™¨å¼€å‘ä¸­æä¸ºæœ‰ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨è°ƒè¯•å’Œæµ‹è¯•é˜¶æ®µã€‚

#### é”™è¯¯å¤„ç†æœºåˆ¶

```moonbit
pub fn parse_expression(tokens: ArrayView[Token]) -> (Expr, ArrayView[Token]) raise {
  // raiseå…³é”®å­—è¡¨ç¤ºæ­¤å‡½æ•°å¯èƒ½æŠ›å‡ºå¼‚å¸¸
}
```

Moonbitçš„ `raise`â€‹ æœºåˆ¶æä¾›äº†ç»“æ„åŒ–çš„é”™è¯¯å¤„ç†ï¼Œä½¿å¾—è¯­æ³•é”™è¯¯èƒ½å¤Ÿè¢«å‡†ç¡®å®šä½å’ŒæŠ¥å‘Šã€‚

é€šè¿‡è¿™ç§åˆ†å±‚è®¾è®¡å’Œé€’å½’ä¸‹é™çš„è§£æç­–ç•¥ï¼Œæˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ªæ—¢çµæ´»åˆé«˜æ•ˆçš„è¯­æ³•åˆ†æå™¨ï¼Œä¸ºåç»­çš„ç±»å‹æ£€æŸ¥é˜¶æ®µå¥ å®šäº†åšå®çš„åŸºç¡€ã€‚

---

## ç¬¬å››ç« ï¼šç±»å‹æ£€æŸ¥ä¸è¯­ä¹‰åˆ†æ

**è¯­ä¹‰åˆ†æ**æ˜¯ç¼–è¯‘å™¨è®¾è®¡ä¸­æ‰¿ä¸Šå¯ä¸‹çš„å…³é”®é˜¶æ®µã€‚è™½ç„¶è¯­æ³•åˆ†æç¡®ä¿äº†ç¨‹åºç»“æ„çš„æ­£ç¡®æ€§ï¼Œä½†è¿™å¹¶ä¸æ„å‘³ç€ç¨‹åºåœ¨è¯­ä¹‰ä¸Šæ˜¯æœ‰æ•ˆçš„ã€‚**ç±»å‹æ£€æŸ¥**ä½œä¸ºè¯­ä¹‰åˆ†æçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œè´Ÿè´£éªŒè¯ç¨‹åºä¸­æ‰€æœ‰æ“ä½œçš„ç±»å‹ä¸€è‡´æ€§ï¼Œç¡®ä¿ç±»å‹å®‰å…¨å’Œè¿è¡Œæ—¶çš„æ­£ç¡®æ€§ã€‚

### ä½œç”¨åŸŸç®¡ç†ï¼šæ„å»ºç¯å¢ƒé“¾

ç±»å‹æ£€æŸ¥é¢ä¸´çš„é¦–è¦æŒ‘æˆ˜æ˜¯æ­£ç¡®å¤„ç†å˜é‡çš„**ä½œç”¨åŸŸ**ï¼ˆScopeï¼‰ã€‚åœ¨ç¨‹åºçš„ä¸åŒå±‚æ¬¡ï¼ˆå…¨å±€ã€å‡½æ•°ã€å—çº§åˆ«ï¼‰ï¼ŒåŒä¸€ä¸ªå˜é‡åå¯èƒ½æŒ‡å‘ä¸åŒçš„å®ä½“ã€‚æˆ‘ä»¬é‡‡ç”¨**ç¯å¢ƒé“¾**ï¼ˆEnvironment Chainï¼‰çš„ç»å…¸è®¾è®¡æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š

```moonbit
pub struct TypeEnv[K, V] {
  parent : TypeEnv[K, V]?     // æŒ‡å‘çˆ¶ç¯å¢ƒçš„å¼•ç”¨
  data : Map[K, V]            // å½“å‰ç¯å¢ƒçš„å˜é‡ç»‘å®š
}
```

ç¯å¢ƒé“¾çš„æ ¸å¿ƒæ˜¯å˜é‡æŸ¥æ‰¾ç®—æ³•ï¼Œå®ƒéµå¾ª**è¯æ³•ä½œç”¨åŸŸ**çš„è§„åˆ™ï¼š

```moonbit
pub fn TypeEnv::get[K : Eq + Hash, V](self : Self[K, V], key : K) -> V? {
  match self.data.get(key) {
    Some(value) => Some(value)    // åœ¨å½“å‰ç¯å¢ƒä¸­æ‰¾åˆ°
    None =>
      match self.parent {
        Some(parent_env) => parent_env.get(key)  // é€’å½’æŸ¥æ‰¾çˆ¶ç¯å¢ƒ
        None => None              // åˆ°è¾¾é¡¶å±‚ç¯å¢ƒï¼Œå˜é‡æœªå®šä¹‰
      }
  }
}
```

> **è®¾è®¡åŸåˆ™ï¼šè¯æ³•ä½œç”¨åŸŸ**
>
> è¿™ç§è®¾è®¡ç¡®ä¿äº†å˜é‡çš„æŸ¥æ‰¾éµå¾ªè¯æ³•ä½œç”¨åŸŸè§„åˆ™ï¼š
>
> 1. é¦–å…ˆåœ¨å½“å‰ä½œç”¨åŸŸä¸­æŸ¥æ‰¾
> 2. å¦‚æœæœªæ‰¾åˆ°ï¼Œå‘ä¸Šå±‚ä½œç”¨åŸŸé€’å½’æŸ¥æ‰¾
> 3. ç›´åˆ°æ‰¾åˆ°å˜é‡æˆ–åˆ°è¾¾å…¨å±€ä½œç”¨åŸŸ

### ç±»å‹æ£€æŸ¥å™¨æ¶æ„

å•çº¯çš„ç¯å¢ƒç®¡ç†è¿˜ä¸è¶³ä»¥å®Œæˆç±»å‹æ£€æŸ¥ä»»åŠ¡ã€‚æŸäº›æ“ä½œï¼ˆå¦‚å‡½æ•°è°ƒç”¨ï¼‰éœ€è¦è®¿é—®å…¨å±€çš„ç¨‹åºä¿¡æ¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ªç»¼åˆçš„ç±»å‹æ£€æŸ¥å™¨ï¼š

```moonbit
pub struct TypeChecker {
  local_env : TypeEnv[String, Type]    // æœ¬åœ°å˜é‡ç¯å¢ƒ
  current_func : Function              // å½“å‰æ£€æŸ¥çš„å‡½æ•°
  program : Program                    // å®Œæ•´çš„ç¨‹åºä¿¡æ¯
}
```

### éƒ¨åˆ†èŠ‚ç‚¹ç±»å‹æ£€æŸ¥çš„å®ç°

ç±»å‹æ£€æŸ¥å™¨çš„æ ¸å¿ƒæ˜¯å¯¹ä¸åŒASTèŠ‚ç‚¹åº”ç”¨ç›¸åº”çš„ç±»å‹è§„åˆ™ã€‚ä»¥ä¸‹æ˜¯è¡¨è¾¾å¼ç±»å‹æ£€æŸ¥çš„å®ç°ï¼š

```moonbit
pub fn Expr::check_type(
  self : Self,
  env : TypeEnv[String, Type]
) -> Type raise {
  match self {
    // åŸå­è¡¨è¾¾å¼çš„ç±»å‹æ£€æŸ¥
    AtomExpr(atom_expr, ..) as node => {
      let ty = atom_expr.check_type(env)
      node.ty = Some(ty)  // å¡«å……ç±»å‹ä¿¡æ¯
      ty
    }

    // ä¸€å…ƒè¿ç®—çš„ç±»å‹æ£€æŸ¥
    Unary("-", expr, ..) as node => {
      let ty = expr.check_type(env)
      node.ty = Some(ty)
      ty
    }

    // äºŒå…ƒè¿ç®—çš„ç±»å‹æ£€æŸ¥
    Binary(""+, lhs, rhs, ..) as node => {
      let lhs_type = lhs.check_type(env)
      let rhs_type = rhs.check_type(env)

      // ç¡®ä¿æ“ä½œæ•°ç±»å‹ä¸€è‡´
      guard lhs_type == rhs_type else {
        raise TypeCheckError(
          "Binary operation requires matching types, got \{lhs_type} and \{rhs_type}"
        )
      }

      let result_type = match op {
        // æ¯”è¾ƒè¿ç®—ç¬¦æ€»æ˜¯è¿”å›å¸ƒå°”å€¼
        "==" | "!=" | "<" | "<=" | ">" | ">=" => Type::Bool

        // ç®—æœ¯è¿ç®—ç¬¦ç­‰ä¿æŒæ“ä½œæ•°ç±»å‹
        _ => lhs_type
      }

      node.ty = Some(result_type)
      result_type
    }
  }
}
```

** ğŸ’¡ Moonbitæšä¸¾ä¿®æ”¹æŠ€å·§ **

åœ¨ç±»å‹æ£€æŸ¥è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºASTèŠ‚ç‚¹å¡«å……ç±»å‹ä¿¡æ¯ã€‚Moonbitæä¾›äº†ä¸€ç§ä¼˜é›…çš„æ–¹å¼æ¥ä¿®æ”¹æšä¸¾å˜ä½“çš„å¯å˜å­—æ®µï¼š

```moonbit
pub enum Expr {
  AtomExpr(AtomExpr, mut ty~ : Type?)
  Unary(String, Expr, mut ty~ : Type?)
  Binary(String, Expr, Expr, mut ty~ : Type?)
} derive(Show, Eq, ToJson)
```

é€šè¿‡åœ¨æ¨¡å¼åŒ¹é…ä¸­ä½¿ç”¨ `as`â€‹ ç»‘å®šï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—å¯¹æšä¸¾å˜ä½“çš„å¼•ç”¨å¹¶ä¿®æ”¹å…¶å¯å˜å­—æ®µï¼š

```moonbit
match expr {
  AtomExpr(atom_expr, ..) as node => {
    let ty = atom_expr.check_type(env)
    node.ty = Some(ty)  // ä¿®æ”¹å¯å˜å­—æ®µ
    ty
  }
  // ...
}
```

è¿™ç§è®¾è®¡é¿å…äº†é‡æ–°æ„å»ºæ•´ä¸ªASTçš„å¼€é”€ï¼ŒåŒæ—¶ä¿æŒäº†å‡½æ•°å¼ç¼–ç¨‹çš„é£æ ¼ã€‚

---

## å®Œæ•´ç¼–è¯‘æµç¨‹å±•ç¤º

ç»è¿‡è¯æ³•åˆ†æã€è¯­æ³•åˆ†æå’Œç±»å‹æ£€æŸ¥ä¸‰ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬çš„ç¼–è¯‘å™¨å‰ç«¯å·²ç»èƒ½å¤Ÿå°†æºä»£ç è½¬æ¢ä¸ºå®Œå…¨ç±»å‹åŒ–çš„æŠ½è±¡è¯­æ³•æ ‘ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥å±•ç¤ºå®Œæ•´çš„è¿‡ç¨‹ï¼š

### æºä»£ç ç¤ºä¾‹

```moonbit
fn add(x: Int, y: Int) -> Int {
  return x + y;
}
```

### ç¼–è¯‘è¾“å‡ºï¼šç±»å‹åŒ–AST

åˆ©ç”¨ `derive(ToJson)`â€‹ åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥å°†æœ€ç»ˆçš„ASTè¾“å‡ºä¸ºJSONæ ¼å¼è¿›è¡ŒæŸ¥çœ‹ï¼š

```json
{
  "functions": {
    "add": {
      "name": "add",
      "params": [
        ["x", { "$tag": "Int" }],
        ["y", { "$tag": "Int" }]
      ],
      "ret_ty": { "$tag": "Int" },
      "body": [
        {
          "$tag": "Return",
          "0": {
            "$tag": "Binary",
            "0": "+",
            "1": {
              "$tag": "AtomExpr",
              "0": {
                "$tag": "Var",
                "0": "x",
                "ty": { "$tag": "Int" }
              },
              "ty": { "$tag": "Int" }
            },
            "2": {
              "$tag": "AtomExpr",
              "0": {
                "$tag": "Var",
                "0": "y",
                "ty": { "$tag": "Int" }
              },
              "ty": { "$tag": "Int" }
            },
            "ty": { "$tag": "Int" }
          }
        }
      ]
    }
  }
}
```

ä»è¿™ä¸ªJSONè¾“å‡ºä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°ï¼š

1. **å®Œæ•´çš„å‡½æ•°ç­¾å**ï¼šåŒ…æ‹¬å‚æ•°åˆ—è¡¨å’Œè¿”å›ç±»å‹
2. **ç±»å‹æ ‡è®°çš„ASTèŠ‚ç‚¹**ï¼šæ¯ä¸ªè¡¨è¾¾å¼éƒ½æºå¸¦äº†ç±»å‹ä¿¡æ¯
3. **ç»“æ„åŒ–çš„ç¨‹åºè¡¨ç¤º**ï¼šä¸ºåç»­çš„ä»£ç ç”Ÿæˆé˜¶æ®µæä¾›äº†æ¸…æ™°çš„æ•°æ®ç»“æ„

---

## ç»“è¯­

é€šè¿‡æœ¬ç¯‡æ–‡ç« ï¼Œæˆ‘ä»¬æ·±å…¥æ¢è®¨äº†ç¼–è¯‘å™¨å‰ç«¯çš„å®Œæ•´å®ç°æµç¨‹ã€‚ä»å­—ç¬¦æµåˆ°ç±»å‹åŒ–çš„æŠ½è±¡è¯­æ³•æ ‘ï¼Œæˆ‘ä»¬è§è¯äº†Moonbitè¯­è¨€åœ¨ç¼–è¯‘å™¨æ„å»ºä¸­çš„ç‹¬ç‰¹ä¼˜åŠ¿ï¼š

### æ ¸å¿ƒæ”¶è·

1. **æ¨¡å¼åŒ¹é…çš„å¨åŠ›**ï¼šMoonbitçš„å­—ç¬¦ä¸²æ¨¡å¼åŒ¹é…å’Œç»“æ„åŒ–æ¨¡å¼åŒ¹é…æå¤§ç®€åŒ–äº†è¯æ³•åˆ†æå’Œè¯­æ³•åˆ†æçš„å®ç°
2. **å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼**ï¼š`loop`â€‹æ„é€ ã€ç¯å¢ƒé“¾å’Œä¸å¯å˜æ•°æ®ç»“æ„çš„ç»“åˆï¼Œæä¾›äº†æ—¢ä¼˜é›…åˆé«˜æ•ˆçš„è§£å†³æ–¹æ¡ˆ
3. **ç±»å‹ç³»ç»Ÿçš„è¡¨è¾¾åŠ›**ï¼šé€šè¿‡æšä¸¾çš„å¯å˜å­—æ®µå’Œtraitå¯¹è±¡ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ„å»ºæ—¢ç±»å‹å®‰å…¨åˆçµæ´»çš„æ•°æ®ç»“æ„
4. **å·¥ç¨‹åŒ–ç‰¹æ€§**ï¼š`derive`â€‹åŠŸèƒ½ã€ç»“æ„åŒ–é”™è¯¯å¤„ç†å’ŒJSONåºåˆ—åŒ–ç­‰ç‰¹æ€§ï¼Œå¤§å¤§æå‡äº†å¼€å‘æ•ˆç‡

### å±•æœ›ä¸‹ç¯‡

åœ¨æŒæ¡äº†è¯­æ³•å‰ç«¯çš„å®ç°ä¹‹åï¼Œä¸‹ç¯‡æ–‡ç« å°†å¼•å¯¼æˆ‘ä»¬è¿›å…¥æ›´åŠ æ¿€åŠ¨äººå¿ƒçš„ä»£ç ç”Ÿæˆé˜¶æ®µã€‚æˆ‘ä»¬å°†ï¼š

- æ·±å…¥äº†è§£LLVMä¸­é—´è¡¨ç¤ºçš„è®¾è®¡å“²å­¦
- æ¢ç´¢Moonbitå®˜æ–¹`llvm.mbt`â€‹ç»‘å®šåº“çš„ä½¿ç”¨æ–¹æ³•
- å®ç°ä»ASTåˆ°LLVM IRçš„å®Œæ•´è½¬æ¢
- ç”Ÿæˆå¯æ‰§è¡Œçš„RISC-Væ±‡ç¼–ä»£ç 

ç¼–è¯‘å™¨çš„æ„å»ºæ˜¯ä¸€ä¸ªå¤æ‚è€Œå¯Œæœ‰æŒ‘æˆ˜æ€§çš„è¿‡ç¨‹ï¼Œä½†æ­£å¦‚æˆ‘ä»¬åœ¨æœ¬ç¯‡ä¸­æ‰€å±•ç¤ºçš„ï¼ŒMoonbitä¸ºè¿™ä¸ªè¿‡ç¨‹æä¾›äº†å¼ºå¤§è€Œä¼˜é›…çš„å·¥å…·ã€‚è®©æˆ‘ä»¬åœ¨ä¸‹ç¯‡ä¸­ç»§ç»­è¿™æ®µä»¤äººå…´å¥‹çš„ç¼–è¯‘å™¨æ„å»ºä¹‹æ—…ã€‚

> **èµ„æºæ¨è**
>
> - [Moonbitå®˜æ–¹æ–‡æ¡£](https://www.moonbitlang.com/docs/)
> - [llvm.mbtæ–‡æ¡£](https://mooncakes.io/docs/Kaida-Amethyst/llvm)
> - [llvm.mbté¡¹ç›®](https://github.com/moonbitlang/llvm.mbt)
> - [LLVMå®˜æ–¹æ•™ç¨‹](https://llvm.org/docs/tutorial/)

---
